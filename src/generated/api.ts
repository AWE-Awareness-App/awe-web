/* tslint:disable */
/* eslint-disable */
/**
 * TypeScript Backend API
 * A TypeScript backend API with OpenAPI specification
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AuthResponse
 */
export interface AuthResponse {
    /**
     * JWT token for authentication
     * @type {string}
     * @memberof AuthResponse
     */
    'token'?: string;
    /**
     * 
     * @type {AuthResponseUser}
     * @memberof AuthResponse
     */
    'user'?: AuthResponseUser;
}
/**
 * 
 * @export
 * @interface AuthResponseUser
 */
export interface AuthResponseUser {
    /**
     * Unique identifier for the user
     * @type {string}
     * @memberof AuthResponseUser
     */
    'id'?: string;
    /**
     * User\'s email address
     * @type {string}
     * @memberof AuthResponseUser
     */
    'email'?: string;
    /**
     * User\'s first name
     * @type {string}
     * @memberof AuthResponseUser
     */
    'firstName'?: string;
    /**
     * User\'s last name
     * @type {string}
     * @memberof AuthResponseUser
     */
    'lastName'?: string;
    /**
     * User\'s role
     * @type {string}
     * @memberof AuthResponseUser
     */
    'role'?: AuthResponseUserRoleEnum;
    /**
     * Whether the user is a counsellor
     * @type {boolean}
     * @memberof AuthResponseUser
     */
    'isCounsellor'?: boolean;
    /**
     * URL to the user\'s profile image
     * @type {string}
     * @memberof AuthResponseUser
     */
    'profileImageUrl'?: string | null;
}

export const AuthResponseUserRoleEnum = {
    Admin: 'ADMIN',
    Coach: 'COACH',
    Patient: 'PATIENT',
    Speaker: 'SPEAKER'
} as const;

export type AuthResponseUserRoleEnum = typeof AuthResponseUserRoleEnum[keyof typeof AuthResponseUserRoleEnum];

/**
 * 
 * @export
 * @interface BasicBlogPost
 */
export interface BasicBlogPost {
    /**
     * 
     * @type {string}
     * @memberof BasicBlogPost
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BasicBlogPost
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof BasicBlogPost
     */
    'shortDescription': string;
    /**
     * 
     * @type {string}
     * @memberof BasicBlogPost
     */
    'imageUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BasicBlogPost
     */
    'authorName': string;
    /**
     * 
     * @type {string}
     * @memberof BasicBlogPost
     */
    'publishDate': string;
    /**
     * Estimated reading time in minutes
     * @type {number}
     * @memberof BasicBlogPost
     */
    'readTime': number;
    /**
     * URL-friendly version of the blog post title
     * @type {string}
     * @memberof BasicBlogPost
     */
    'slug': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BasicBlogPost
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface BlogPost
 */
export interface BlogPost {
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    'shortDescription': string;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    'imageUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    'authorName': string;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    'authorImageUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    'publishDate': string;
    /**
     * Estimated reading time in minutes
     * @type {number}
     * @memberof BlogPost
     */
    'readTime': number;
    /**
     * URL-friendly version of the blog post title
     * @type {string}
     * @memberof BlogPost
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof BlogPost
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BlogPost
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface BlogsGet200Response
 */
export interface BlogsGet200Response {
    /**
     * 
     * @type {Array<BasicBlogPost>}
     * @memberof BlogsGet200Response
     */
    'items'?: Array<BasicBlogPost>;
    /**
     * 
     * @type {BlogsGet200ResponsePagination}
     * @memberof BlogsGet200Response
     */
    'pagination'?: BlogsGet200ResponsePagination;
}
/**
 * 
 * @export
 * @interface BlogsGet200ResponsePagination
 */
export interface BlogsGet200ResponsePagination {
    /**
     * Total number of items across all pages
     * @type {number}
     * @memberof BlogsGet200ResponsePagination
     */
    'totalItems'?: number;
    /**
     * Total number of pages available
     * @type {number}
     * @memberof BlogsGet200ResponsePagination
     */
    'totalPages'?: number;
    /**
     * The current page number (1-based index)
     * @type {number}
     * @memberof BlogsGet200ResponsePagination
     */
    'currentPage'?: number;
    /**
     * Number of items per page
     * @type {number}
     * @memberof BlogsGet200ResponsePagination
     */
    'itemsPerPage'?: number;
    /**
     * The next page url, or null if this is the last page
     * @type {string}
     * @memberof BlogsGet200ResponsePagination
     */
    'nextPage'?: string | null;
    /**
     * The previous page url, or null if this is the first page
     * @type {string}
     * @memberof BlogsGet200ResponsePagination
     */
    'previousPage'?: string | null;
}
/**
 * 
 * @export
 * @interface CheckoutSessionRequest
 */
export interface CheckoutSessionRequest {
    /**
     * ID of the workshop to book
     * @type {string}
     * @memberof CheckoutSessionRequest
     */
    'workshopId': string;
    /**
     * URL to redirect to after successful payment
     * @type {string}
     * @memberof CheckoutSessionRequest
     */
    'successUrl': string;
    /**
     * URL to redirect to if payment is canceled
     * @type {string}
     * @memberof CheckoutSessionRequest
     */
    'cancelUrl': string;
    /**
     * Stripe Connect account ID of the workshop host
     * @type {string}
     * @memberof CheckoutSessionRequest
     */
    'connectAccountId': string;
}
/**
 * 
 * @export
 * @interface CheckoutSessionResponse
 */
export interface CheckoutSessionResponse {
    /**
     * Stripe Checkout Session ID
     * @type {string}
     * @memberof CheckoutSessionResponse
     */
    'sessionId': string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * Error message
     * @type {string}
     * @memberof ErrorResponse
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface EventReminder
 */
export interface EventReminder {
    /**
     * 
     * @type {string}
     * @memberof EventReminder
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventReminder
     */
    'workshopId': string;
    /**
     * 
     * @type {string}
     * @memberof EventReminder
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof EventReminder
     */
    'reminderMethod': EventReminderReminderMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof EventReminder
     */
    'delayUnit': EventReminderDelayUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof EventReminder
     */
    'delayAmount': number;
}

export const EventReminderReminderMethodEnum = {
    Email: 'EMAIL',
    Sms: 'SMS'
} as const;

export type EventReminderReminderMethodEnum = typeof EventReminderReminderMethodEnum[keyof typeof EventReminderReminderMethodEnum];
export const EventReminderDelayUnitEnum = {
    Minute: 'MINUTE',
    Hour: 'HOUR',
    Day: 'DAY'
} as const;

export type EventReminderDelayUnitEnum = typeof EventReminderDelayUnitEnum[keyof typeof EventReminderDelayUnitEnum];

/**
 * 
 * @export
 * @interface HealthGet200Response
 */
export interface HealthGet200Response {
    /**
     * 
     * @type {string}
     * @memberof HealthGet200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * User\'s email address
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string;
    /**
     * User\'s password
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
    /**
     * User\'s email address
     * @type {string}
     * @memberof RegisterRequest
     */
    'email': string;
    /**
     * User\'s password
     * @type {string}
     * @memberof RegisterRequest
     */
    'password': string;
    /**
     * User\'s first name
     * @type {string}
     * @memberof RegisterRequest
     */
    'firstName': string;
    /**
     * User\'s last name
     * @type {string}
     * @memberof RegisterRequest
     */
    'lastName': string;
    /**
     * User\'s role
     * @type {string}
     * @memberof RegisterRequest
     */
    'role': RegisterRequestRoleEnum;
}

export const RegisterRequestRoleEnum = {
    Admin: 'ADMIN',
    Coach: 'COACH',
    Patient: 'PATIENT',
    Speaker: 'SPEAKER'
} as const;

export type RegisterRequestRoleEnum = typeof RegisterRequestRoleEnum[keyof typeof RegisterRequestRoleEnum];

/**
 * 
 * @export
 * @interface ResendVerificationRequest
 */
export interface ResendVerificationRequest {
    /**
     * Email address to resend verification to
     * @type {string}
     * @memberof ResendVerificationRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface SuccessResponse
 */
export interface SuccessResponse {
    /**
     * Success message
     * @type {string}
     * @memberof SuccessResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role': UserRoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'isCounsellor'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'reference'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'linkedIn'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'stripeId': string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phoneNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'profileImageUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'gender'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'occupation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'certification'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'calendlyUrl'?: string | null;
}

export const UserRoleEnum = {
    Admin: 'ADMIN',
    Patient: 'PATIENT',
    Speaker: 'SPEAKER',
    Coach: 'COACH'
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];

/**
 * 
 * @export
 * @interface UsersIdPutRequest
 */
export interface UsersIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersIdPutRequest
     */
    'firstname': string;
    /**
     * 
     * @type {string}
     * @memberof UsersIdPutRequest
     */
    'lastname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersIdPutRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UsersIdPutRequest
     */
    'role': string;
}
/**
 * 
 * @export
 * @interface UsersPostRequest
 */
export interface UsersPostRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequest
     */
    'firstname': string;
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequest
     */
    'lastname': string;
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequest
     */
    'role': string;
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequest
     */
    'imageUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequest
     */
    'linkedin': string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequest
     */
    'reference': string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequest
     */
    'stripeId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequest
     */
    'gender'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequest
     */
    'occupation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequest
     */
    'certification'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequest
     */
    'profileImageUrl'?: string;
}
/**
 * 
 * @export
 * @interface ValidationResponse
 */
export interface ValidationResponse {
    /**
     * ID of the authenticated user
     * @type {string}
     * @memberof ValidationResponse
     */
    'userId'?: string;
    /**
     * User\'s role
     * @type {string}
     * @memberof ValidationResponse
     */
    'role'?: ValidationResponseRoleEnum;
}

export const ValidationResponseRoleEnum = {
    Admin: 'ADMIN',
    Coach: 'COACH',
    Patient: 'PATIENT',
    Speaker: 'SPEAKER'
} as const;

export type ValidationResponseRoleEnum = typeof ValidationResponseRoleEnum[keyof typeof ValidationResponseRoleEnum];

/**
 * 
 * @export
 * @interface VerifyEmailRequest
 */
export interface VerifyEmailRequest {
    /**
     * Email verification token received via email
     * @type {string}
     * @memberof VerifyEmailRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface WebhookResponse
 */
export interface WebhookResponse {
    /**
     * Indicates if the webhook was received successfully
     * @type {boolean}
     * @memberof WebhookResponse
     */
    'received': boolean;
}
/**
 * 
 * @export
 * @interface Workshop
 */
export interface Workshop {
    /**
     * 
     * @type {string}
     * @memberof Workshop
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Workshop
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Workshop
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Workshop
     */
    'imageUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Workshop
     */
    'durationText': string;
    /**
     * 
     * @type {number}
     * @memberof Workshop
     */
    'maxSeats': number;
    /**
     * 
     * @type {string}
     * @memberof Workshop
     */
    'startDate': string;
    /**
     * 
     * @type {number}
     * @memberof Workshop
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof Workshop
     */
    'bookingUrl': string;
    /**
     * 
     * @type {string}
     * @memberof Workshop
     */
    'type': WorkshopTypeEnum;
    /**
     * 
     * @type {WorkshopCounsellor}
     * @memberof Workshop
     */
    'counsellor'?: WorkshopCounsellor;
    /**
     * 
     * @type {string}
     * @memberof Workshop
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Workshop
     */
    'updatedAt'?: string;
}

export const WorkshopTypeEnum = {
    Individual: 'INDIVIDUAL',
    Couple: 'COUPLE',
    Family: 'FAMILY',
    Communities: 'COMMUNITIES',
    Organization: 'ORGANIZATION'
} as const;

export type WorkshopTypeEnum = typeof WorkshopTypeEnum[keyof typeof WorkshopTypeEnum];

/**
 * 
 * @export
 * @interface WorkshopBooking
 */
export interface WorkshopBooking {
    /**
     * 
     * @type {string}
     * @memberof WorkshopBooking
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopBooking
     */
    'workshopId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopBooking
     */
    'userId'?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkshopBooking
     */
    'nbSeats': number;
    /**
     * 
     * @type {string}
     * @memberof WorkshopBooking
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopBooking
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {User}
     * @memberof WorkshopBooking
     */
    'user': User;
    /**
     * 
     * @type {Workshop}
     * @memberof WorkshopBooking
     */
    'workshop': Workshop;
}
/**
 * 
 * @export
 * @interface WorkshopBookingsGet500Response
 */
export interface WorkshopBookingsGet500Response {
    /**
     * 
     * @type {string}
     * @memberof WorkshopBookingsGet500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface WorkshopBookingsPostRequest
 */
export interface WorkshopBookingsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkshopBookingsPostRequest
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopBookingsPostRequest
     */
    'workshopId': string;
    /**
     * 
     * @type {number}
     * @memberof WorkshopBookingsPostRequest
     */
    'nbSeats': number;
}
/**
 * 
 * @export
 * @interface WorkshopCounsellor
 */
export interface WorkshopCounsellor {
    /**
     * 
     * @type {string}
     * @memberof WorkshopCounsellor
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopCounsellor
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopCounsellor
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopCounsellor
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopCounsellor
     */
    'role': WorkshopCounsellorRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof WorkshopCounsellor
     */
    'stripeId': string | null;
}

export const WorkshopCounsellorRoleEnum = {
    Admin: 'ADMIN',
    Patient: 'PATIENT',
    Speaker: 'SPEAKER',
    Coach: 'COACH'
} as const;

export type WorkshopCounsellorRoleEnum = typeof WorkshopCounsellorRoleEnum[keyof typeof WorkshopCounsellorRoleEnum];

/**
 * 
 * @export
 * @interface WorkshopUser
 */
export interface WorkshopUser {
    /**
     * 
     * @type {string}
     * @memberof WorkshopUser
     */
    'workshopId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopUser
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopUser
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopUser
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopUser
     */
    'role'?: WorkshopUserRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof WorkshopUser
     */
    'stripeId': string | null;
}

export const WorkshopUserRoleEnum = {
    Admin: 'ADMIN',
    Patient: 'PATIENT',
    Speaker: 'SPEAKER',
    Coach: 'COACH'
} as const;

export type WorkshopUserRoleEnum = typeof WorkshopUserRoleEnum[keyof typeof WorkshopUserRoleEnum];

/**
 * 
 * @export
 * @interface WorkshopsIdPutRequest
 */
export interface WorkshopsIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkshopsIdPutRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopsIdPutRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopsIdPutRequest
     */
    'image'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WorkshopsIdPutRequest
     */
    'duration': number;
    /**
     * 
     * @type {string}
     * @memberof WorkshopsIdPutRequest
     */
    'startDate': string;
    /**
     * 
     * @type {number}
     * @memberof WorkshopsIdPutRequest
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof WorkshopsIdPutRequest
     */
    'bookingUrl': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopsIdPutRequest
     */
    'type': WorkshopsIdPutRequestTypeEnum;
}

export const WorkshopsIdPutRequestTypeEnum = {
    Live: 'LIVE',
    Recording: 'RECORDING',
    Both: 'BOTH'
} as const;

export type WorkshopsIdPutRequestTypeEnum = typeof WorkshopsIdPutRequestTypeEnum[keyof typeof WorkshopsIdPutRequestTypeEnum];

/**
 * 
 * @export
 * @interface WorkshopsPostRequest
 */
export interface WorkshopsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkshopsPostRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopsPostRequest
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopsPostRequest
     */
    'imageUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkshopsPostRequest
     */
    'durationText': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopsPostRequest
     */
    'startDate': string;
    /**
     * 
     * @type {number}
     * @memberof WorkshopsPostRequest
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof WorkshopsPostRequest
     */
    'bookingUrl': string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopsPostRequest
     */
    'type': WorkshopsPostRequestTypeEnum;
}

export const WorkshopsPostRequestTypeEnum = {
    Live: 'LIVE',
    Recording: 'RECORDING',
    Both: 'BOTH'
} as const;

export type WorkshopsPostRequestTypeEnum = typeof WorkshopsPostRequestTypeEnum[keyof typeof WorkshopsPostRequestTypeEnum];


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticates a user. Login will fail with 401 if email is not verified.
         * @summary Login user (requires email verification)
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('authLoginPost', 'loginRequest', loginRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user account and sends an email verification token. Users must verify their email before logging in.
         * @summary Register a new user
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterPost: async (registerRequest: RegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequest' is not null or undefined
            assertParamExists('authRegisterPost', 'registerRequest', registerRequest)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resend email verification token
         * @param {ResendVerificationRequest} resendVerificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResendVerificationPost: async (resendVerificationRequest: ResendVerificationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resendVerificationRequest' is not null or undefined
            assertParamExists('authResendVerificationPost', 'resendVerificationRequest', resendVerificationRequest)
            const localVarPath = `/auth/resend-verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendVerificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authValidateGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify email using verification token
         * @param {VerifyEmailRequest} verifyEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyEmailPost: async (verifyEmailRequest: VerifyEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyEmailRequest' is not null or undefined
            assertParamExists('authVerifyEmailPost', 'verifyEmailRequest', verifyEmailRequest)
            const localVarPath = `/auth/verify-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticates a user. Login will fail with 401 if email is not verified.
         * @summary Login user (requires email verification)
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginPost(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new user account and sends an email verification token. Users must verify their email before logging in.
         * @summary Register a new user
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRegisterPost(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegisterPost(registerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Resend email verification token
         * @param {ResendVerificationRequest} resendVerificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authResendVerificationPost(resendVerificationRequest: ResendVerificationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authResendVerificationPost(resendVerificationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authResendVerificationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Validate authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authValidateGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authValidateGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authValidateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify email using verification token
         * @param {VerifyEmailRequest} verifyEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authVerifyEmailPost(verifyEmailRequest: VerifyEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authVerifyEmailPost(verifyEmailRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authVerifyEmailPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Authenticates a user. Login will fail with 401 if email is not verified.
         * @summary Login user (requires email verification)
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.authLoginPost(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user account and sends an email verification token. Users must verify their email before logging in.
         * @summary Register a new user
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterPost(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.authRegisterPost(registerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resend email verification token
         * @param {ResendVerificationRequest} resendVerificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResendVerificationPost(resendVerificationRequest: ResendVerificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.authResendVerificationPost(resendVerificationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate authentication token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authValidateGet(options?: RawAxiosRequestConfig): AxiosPromise<ValidationResponse> {
            return localVarFp.authValidateGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify email using verification token
         * @param {VerifyEmailRequest} verifyEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyEmailPost(verifyEmailRequest: VerifyEmailRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.authVerifyEmailPost(verifyEmailRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Authenticates a user. Login will fail with 401 if email is not verified.
     * @summary Login user (requires email verification)
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLoginPost(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new user account and sends an email verification token. Users must verify their email before logging in.
     * @summary Register a new user
     * @param {RegisterRequest} registerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRegisterPost(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRegisterPost(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resend email verification token
     * @param {ResendVerificationRequest} resendVerificationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authResendVerificationPost(resendVerificationRequest: ResendVerificationRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authResendVerificationPost(resendVerificationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate authentication token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authValidateGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authValidateGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify email using verification token
     * @param {VerifyEmailRequest} verifyEmailRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authVerifyEmailPost(verifyEmailRequest: VerifyEmailRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authVerifyEmailPost(verifyEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BlogsApi - axios parameter creator
 * @export
 */
export const BlogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get paginated list of blog posts
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blogsGet: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/blogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a blog post by slug
         * @param {string} slug URL-friendly version of the blog post title (slug)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blogsSlugGet: async (slug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('blogsSlugGet', 'slug', slug)
            const localVarPath = `/blogs/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlogsApi - functional programming interface
 * @export
 */
export const BlogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get paginated list of blog posts
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blogsGet(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blogsGet(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlogsApi.blogsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a blog post by slug
         * @param {string} slug URL-friendly version of the blog post title (slug)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blogsSlugGet(slug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogPost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blogsSlugGet(slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlogsApi.blogsSlugGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BlogsApi - factory interface
 * @export
 */
export const BlogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlogsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get paginated list of blog posts
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blogsGet(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<BlogsGet200Response> {
            return localVarFp.blogsGet(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a blog post by slug
         * @param {string} slug URL-friendly version of the blog post title (slug)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blogsSlugGet(slug: string, options?: RawAxiosRequestConfig): AxiosPromise<BlogPost> {
            return localVarFp.blogsSlugGet(slug, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlogsApi - object-oriented interface
 * @export
 * @class BlogsApi
 * @extends {BaseAPI}
 */
export class BlogsApi extends BaseAPI {
    /**
     * 
     * @summary Get paginated list of blog posts
     * @param {number} [page] Page number
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public blogsGet(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return BlogsApiFp(this.configuration).blogsGet(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a blog post by slug
     * @param {string} slug URL-friendly version of the blog post title (slug)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public blogsSlugGet(slug: string, options?: RawAxiosRequestConfig) {
        return BlogsApiFp(this.configuration).blogsSlugGet(slug, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all workshop bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workshopBookingsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workshopBookings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.healthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all workshop bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workshopBookingsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkshopBooking>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workshopBookingsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.workshopBookingsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet(options?: RawAxiosRequestConfig): AxiosPromise<HealthGet200Response> {
            return localVarFp.healthGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all workshop bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workshopBookingsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkshopBooking>> {
            return localVarFp.workshopBookingsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public healthGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all workshop bookings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public workshopBookingsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).workshopBookingsGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Stripe Checkout session for workshop booking
         * @param {CheckoutSessionRequest} checkoutSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsCheckoutSessionPost: async (checkoutSessionRequest: CheckoutSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkoutSessionRequest' is not null or undefined
            assertParamExists('apiPaymentsCheckoutSessionPost', 'checkoutSessionRequest', checkoutSessionRequest)
            const localVarPath = `/api/payments/checkout-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Handle Stripe webhook events
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsWebhookPost: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('apiPaymentsWebhookPost', 'body', body)
            const localVarPath = `/api/payments/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new Stripe Checkout session for workshop booking
         * @param {CheckoutSessionRequest} checkoutSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentsCheckoutSessionPost(checkoutSessionRequest: CheckoutSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentsCheckoutSessionPost(checkoutSessionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.apiPaymentsCheckoutSessionPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Handle Stripe webhook events
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPaymentsWebhookPost(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPaymentsWebhookPost(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.apiPaymentsWebhookPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new Stripe Checkout session for workshop booking
         * @param {CheckoutSessionRequest} checkoutSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsCheckoutSessionPost(checkoutSessionRequest: CheckoutSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CheckoutSessionResponse> {
            return localVarFp.apiPaymentsCheckoutSessionPost(checkoutSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Handle Stripe webhook events
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPaymentsWebhookPost(body: object, options?: RawAxiosRequestConfig): AxiosPromise<WebhookResponse> {
            return localVarFp.apiPaymentsWebhookPost(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Stripe Checkout session for workshop booking
     * @param {CheckoutSessionRequest} checkoutSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public apiPaymentsCheckoutSessionPost(checkoutSessionRequest: CheckoutSessionRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).apiPaymentsCheckoutSessionPost(checkoutSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Handle Stripe webhook events
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public apiPaymentsWebhookPost(body: object, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).apiPaymentsWebhookPost(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdDelete', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdGet', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user
         * @param {string} id 
         * @param {UsersIdPutRequest} usersIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPut: async (id: string, usersIdPutRequest: UsersIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdPut', 'id', id)
            // verify required parameter 'usersIdPutRequest' is not null or undefined
            assertParamExists('usersIdPut', 'usersIdPutRequest', usersIdPutRequest)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new user
         * @param {UsersPostRequest} usersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost: async (usersPostRequest: UsersPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usersPostRequest' is not null or undefined
            assertParamExists('usersPost', 'usersPostRequest', usersPostRequest)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a user by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a user
         * @param {string} id 
         * @param {UsersIdPutRequest} usersIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdPut(id: string, usersIdPutRequest: UsersIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdPut(id, usersIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new user
         * @param {UsersPostRequest} usersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPost(usersPostRequest: UsersPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPost(usersPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.usersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user
         * @param {string} id 
         * @param {UsersIdPutRequest} usersIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdPut(id: string, usersIdPutRequest: UsersIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersIdPut(id, usersIdPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new user
         * @param {UsersPostRequest} usersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(usersPostRequest: UsersPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersPost(usersPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGet(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdGet(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user
     * @param {string} id 
     * @param {UsersIdPutRequest} usersIdPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdPut(id: string, usersIdPutRequest: UsersIdPutRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersIdPut(id, usersIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new user
     * @param {UsersPostRequest} usersPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPost(usersPostRequest: UsersPostRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPost(usersPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkshopBookingsApi - axios parameter creator
 * @export
 */
export const WorkshopBookingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new workshop booking
         * @param {WorkshopBookingsPostRequest} workshopBookingsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workshopBookingsPost: async (workshopBookingsPostRequest: WorkshopBookingsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workshopBookingsPostRequest' is not null or undefined
            assertParamExists('workshopBookingsPost', 'workshopBookingsPostRequest', workshopBookingsPostRequest)
            const localVarPath = `/workshopBookings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workshopBookingsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkshopBookingsApi - functional programming interface
 * @export
 */
export const WorkshopBookingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkshopBookingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new workshop booking
         * @param {WorkshopBookingsPostRequest} workshopBookingsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workshopBookingsPost(workshopBookingsPostRequest: WorkshopBookingsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workshop>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workshopBookingsPost(workshopBookingsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkshopBookingsApi.workshopBookingsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkshopBookingsApi - factory interface
 * @export
 */
export const WorkshopBookingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkshopBookingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new workshop booking
         * @param {WorkshopBookingsPostRequest} workshopBookingsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workshopBookingsPost(workshopBookingsPostRequest: WorkshopBookingsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Workshop> {
            return localVarFp.workshopBookingsPost(workshopBookingsPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkshopBookingsApi - object-oriented interface
 * @export
 * @class WorkshopBookingsApi
 * @extends {BaseAPI}
 */
export class WorkshopBookingsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new workshop booking
     * @param {WorkshopBookingsPostRequest} workshopBookingsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkshopBookingsApi
     */
    public workshopBookingsPost(workshopBookingsPostRequest: WorkshopBookingsPostRequest, options?: RawAxiosRequestConfig) {
        return WorkshopBookingsApiFp(this.configuration).workshopBookingsPost(workshopBookingsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkshopsApi - axios parameter creator
 * @export
 */
export const WorkshopsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all workshops
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workshopsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workshops`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a workshop
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workshopsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workshopsIdDelete', 'id', id)
            const localVarPath = `/workshops/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a workshop by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workshopsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workshopsIdGet', 'id', id)
            const localVarPath = `/workshops/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a workshop
         * @param {string} id 
         * @param {WorkshopsIdPutRequest} workshopsIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workshopsIdPut: async (id: string, workshopsIdPutRequest: WorkshopsIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workshopsIdPut', 'id', id)
            // verify required parameter 'workshopsIdPutRequest' is not null or undefined
            assertParamExists('workshopsIdPut', 'workshopsIdPutRequest', workshopsIdPutRequest)
            const localVarPath = `/workshops/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workshopsIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new workshop
         * @param {WorkshopsPostRequest} workshopsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workshopsPost: async (workshopsPostRequest: WorkshopsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workshopsPostRequest' is not null or undefined
            assertParamExists('workshopsPost', 'workshopsPostRequest', workshopsPostRequest)
            const localVarPath = `/workshops`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workshopsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkshopsApi - functional programming interface
 * @export
 */
export const WorkshopsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkshopsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all workshops
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workshopsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workshop>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workshopsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkshopsApi.workshopsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a workshop
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workshopsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workshopsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkshopsApi.workshopsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a workshop by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workshopsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workshop>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workshopsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkshopsApi.workshopsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a workshop
         * @param {string} id 
         * @param {WorkshopsIdPutRequest} workshopsIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workshopsIdPut(id: string, workshopsIdPutRequest: WorkshopsIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workshop>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workshopsIdPut(id, workshopsIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkshopsApi.workshopsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new workshop
         * @param {WorkshopsPostRequest} workshopsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workshopsPost(workshopsPostRequest: WorkshopsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workshop>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workshopsPost(workshopsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkshopsApi.workshopsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkshopsApi - factory interface
 * @export
 */
export const WorkshopsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkshopsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all workshops
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workshopsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Workshop>> {
            return localVarFp.workshopsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a workshop
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workshopsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.workshopsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a workshop by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workshopsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Workshop> {
            return localVarFp.workshopsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a workshop
         * @param {string} id 
         * @param {WorkshopsIdPutRequest} workshopsIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workshopsIdPut(id: string, workshopsIdPutRequest: WorkshopsIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Workshop> {
            return localVarFp.workshopsIdPut(id, workshopsIdPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new workshop
         * @param {WorkshopsPostRequest} workshopsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workshopsPost(workshopsPostRequest: WorkshopsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Workshop> {
            return localVarFp.workshopsPost(workshopsPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkshopsApi - object-oriented interface
 * @export
 * @class WorkshopsApi
 * @extends {BaseAPI}
 */
export class WorkshopsApi extends BaseAPI {
    /**
     * 
     * @summary Get all workshops
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkshopsApi
     */
    public workshopsGet(options?: RawAxiosRequestConfig) {
        return WorkshopsApiFp(this.configuration).workshopsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a workshop
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkshopsApi
     */
    public workshopsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return WorkshopsApiFp(this.configuration).workshopsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a workshop by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkshopsApi
     */
    public workshopsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return WorkshopsApiFp(this.configuration).workshopsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a workshop
     * @param {string} id 
     * @param {WorkshopsIdPutRequest} workshopsIdPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkshopsApi
     */
    public workshopsIdPut(id: string, workshopsIdPutRequest: WorkshopsIdPutRequest, options?: RawAxiosRequestConfig) {
        return WorkshopsApiFp(this.configuration).workshopsIdPut(id, workshopsIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new workshop
     * @param {WorkshopsPostRequest} workshopsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkshopsApi
     */
    public workshopsPost(workshopsPostRequest: WorkshopsPostRequest, options?: RawAxiosRequestConfig) {
        return WorkshopsApiFp(this.configuration).workshopsPost(workshopsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



